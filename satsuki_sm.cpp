/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : satsuki.sm
 */

#include "engine.hpp"
#include "./satsuki_sm.h"

using namespace statemap;

namespace Turnstile
{
    // Static class declarations.
    MainMap_Normal MainMap::Normal("MainMap::Normal", 0);
    MainMap_Shift MainMap::Shift("MainMap::Shift", 1);
    MainMap_Tenkey MainMap::Tenkey("MainMap::Tenkey", 2);
    MainMap_PostSpace MainMap::PostSpace("MainMap::PostSpace", 3);
    MainMap_NestedSpace MainMap::NestedSpace("MainMap::NestedSpace", 4);
    MainMap_NestedZKeyControl MainMap::NestedZKeyControl("MainMap::NestedZKeyControl", 5);
    MainMap_NestedSlashControl MainMap::NestedSlashControl("MainMap::NestedSlashControl", 6);
    MainMap_PreSpace MainMap::PreSpace("MainMap::PreSpace", 7);
    MainMap_Space MainMap::Space("MainMap::Space", 8);
    MainMap_PreZKeyControl MainMap::PreZKeyControl("MainMap::PreZKeyControl", 9);
    MainMap_PreSlashControl MainMap::PreSlashControl("MainMap::PreSlashControl", 10);
    MainMap_SemiZKeyControl MainMap::SemiZKeyControl("MainMap::SemiZKeyControl", 11);
    MainMap_SemiSlashControl MainMap::SemiSlashControl("MainMap::SemiSlashControl", 12);
    MainMap_ZKeyControl MainMap::ZKeyControl("MainMap::ZKeyControl", 13);
    MainMap_SlashControl MainMap::SlashControl("MainMap::SlashControl", 14);

    void TurnstileState::keydown(satsukiContext& context, KeyEvent event)
    {
        Default(context);
        return;
    }

    void TurnstileState::keyup(satsukiContext& context, KeyEvent event)
    {
        Default(context);
        return;
    }

    void TurnstileState::Default(satsukiContext& context)
    {
        throw (
            TransitionUndefinedException(
                context.getState().getName(),
                context.getTransition()));

        return;
    }

    void MainMap_Normal::keydown(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_space )
        {
            // No actions.
            context.pushState(MainMap::PreSpace);
            (context.getState()).Entry(context);
        }
        else if ( event.is_slash )
    
    {
            // No actions.
            context.pushState(MainMap::PreSlashControl);
            (context.getState()).Entry(context);
        }
        else if ( event.is_z )
    
    {
            // No actions.
            context.pushState(MainMap::PreZKeyControl);
            (context.getState()).Entry(context);
        }
        else if ( event.is_shift )
    
    {
            // No actions.
            context.pushState(MainMap::Shift);
            (context.getState()).Entry(context);
        }
        else if ( event.is_tenkey )
    
    {
            // No actions.
            context.pushState(MainMap::Tenkey);
            (context.getState()).Entry(context);
        }
        else
        {
            TurnstileState& endState = context.getState();

            context.clearState();
            try
            {
                ctxt.emit(event);
                context.setState(endState);
            }
            catch (...)
            {
                context.setState(endState);
                throw;
            }
        }

        return;
    }

    void MainMap_Shift::Entry(satsukiContext& context)

{
        Turnstile& ctxt = context.getOwner();

        ctxt.shift_mode(True);
        return;
    }

    void MainMap_Shift::Exit(satsukiContext& context)

{
        Turnstile& ctxt = context.getOwner();

        ctxt.shift_mode(False);
        return;
    }

    void MainMap_Shift::keydown(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        TurnstileState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.emit(event);
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }

        return;
    }

    void MainMap_Shift::keyup(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_shift )
        {
            (context.getState()).Exit(context);
            // No actions.
            context.popState();
        }
        else
        {
            TurnstileState& endState = context.getState();

            context.clearState();
            try
            {
                ctxt.emit(event);
                context.setState(endState);
            }
            catch (...)
            {
                context.setState(endState);
                throw;
            }
        }

        return;
    }

    void MainMap_Tenkey::Entry(satsukiContext& context)

{
        Turnstile& ctxt = context.getOwner();

        ctxt.tenkey_mode(True);
        return;
    }

    void MainMap_Tenkey::Exit(satsukiContext& context)

{
        Turnstile& ctxt = context.getOwner();

        ctxt.tenkey_mode(False);
        return;
    }

    void MainMap_Tenkey::keydown(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        TurnstileState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.emit(event);
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }

        return;
    }

    void MainMap_Tenkey::keyup(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_tenkey )
        {
            (context.getState()).Exit(context);
            // No actions.
            context.popState();
        }
        else
        {
            TurnstileState& endState = context.getState();

            context.clearState();
            try
            {
                ctxt.emit(event);
                context.setState(endState);
            }
            catch (...)
            {
                context.setState(endState);
                throw;
            }
        }

        return;
    }

    void MainMap_PostSpace::keydown(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        TurnstileState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.emit(event);
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }

        return;
    }

    void MainMap_PostSpace::keyup(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_space )
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.pop_state();
                context.popState();
            }
            catch (...)
            {
                context.popState();
                throw;
            }
        }
        else
        {
            TurnstileState& endState = context.getState();

            context.clearState();
            try
            {
                ctxt.emit(event);
                context.setState(endState);
            }
            catch (...)
            {
                context.setState(endState);
                throw;
            }
        }

        return;
    }

    void MainMap_NestedSpace::Entry(satsukiContext& context)

{
        Turnstile& ctxt = context.getOwner();

        ctxt.space_mode(True);
        return;
    }

    void MainMap_NestedSpace::Exit(satsukiContext& context)

{
        Turnstile& ctxt = context.getOwner();

        ctxt.space_mode(False);
        return;
    }

    void MainMap_NestedSpace::keydown(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        TurnstileState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.emit(event);
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }

        return;
    }

    void MainMap_NestedSpace::keyup(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_space )
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.pop_state();
                context.popState();
            }
            catch (...)
            {
                context.popState();
                throw;
            }
        }
        else
        {
            TurnstileState& endState = context.getState();

            context.clearState();
            try
            {
                ctxt.emit(event);
                context.setState(endState);
            }
            catch (...)
            {
                context.setState(endState);
                throw;
            }
        }

        return;
    }

    void MainMap_NestedZKeyControl::Entry(satsukiContext& context)

{
        Turnstile& ctxt = context.getOwner();

        ctxt.control_mode(True);
        return;
    }

    void MainMap_NestedZKeyControl::Exit(satsukiContext& context)

{
        Turnstile& ctxt = context.getOwner();

        ctxt.control_mode(False);
        return;
    }

    void MainMap_NestedZKeyControl::keydown(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_z )
        {
            // No actions.
        }
        else
        {
            TurnstileState& endState = context.getState();

            context.clearState();
            try
            {
                ctxt.emit(event);
                context.setState(endState);
            }
            catch (...)
            {
                context.setState(endState);
                throw;
            }
        }

        return;
    }

    void MainMap_NestedZKeyControl::keyup(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_z )
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.pop_state();
                context.popState();
            }
            catch (...)
            {
                context.popState();
                throw;
            }
        }
        else
        {
            TurnstileState& endState = context.getState();

            context.clearState();
            try
            {
                ctxt.emit(event);
                context.setState(endState);
            }
            catch (...)
            {
                context.setState(endState);
                throw;
            }
        }

        return;
    }

    void MainMap_NestedSlashControl::Entry(satsukiContext& context)

{
        Turnstile& ctxt = context.getOwner();

        ctxt.control_mode(True);
        return;
    }

    void MainMap_NestedSlashControl::Exit(satsukiContext& context)

{
        Turnstile& ctxt = context.getOwner();

        ctxt.control_mode(False);
        return;
    }

    void MainMap_NestedSlashControl::keydown(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_slash )
        {
            // No actions.
        }
        else
        {
            TurnstileState& endState = context.getState();

            context.clearState();
            try
            {
                ctxt.emit(event);
                context.setState(endState);
            }
            catch (...)
            {
                context.setState(endState);
                throw;
            }
        }

        return;
    }

    void MainMap_NestedSlashControl::keyup(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_slash )
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.pop_state();
                context.popState();
            }
            catch (...)
            {
                context.popState();
                throw;
            }
        }
        else
        {
            TurnstileState& endState = context.getState();

            context.clearState();
            try
            {
                ctxt.emit(event);
                context.setState(endState);
            }
            catch (...)
            {
                context.setState(endState);
                throw;
            }
        }

        return;
    }

    void MainMap_PreSpace::keydown(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_slash )
        {
            (context.getState()).Exit(context);
            // No actions.
            context.setState(MainMap::Space);

            (context.getState()).Entry(context);
            context.pushState(MainMap::PreSlashControl);
            (context.getState()).Entry(context);
        }
        else if ( event.is_z )
    
    {
            (context.getState()).Exit(context);
            // No actions.
            context.setState(MainMap::Space);

            (context.getState()).Entry(context);
            context.pushState(MainMap::PreZKeyControl);
            (context.getState()).Entry(context);
        }
        else if ( event.is_space )
    
    {
            (context.getState()).Exit(context);
            // No actions.
            context.setState(MainMap::Space);
            (context.getState()).Entry(context);
        }
        else
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.space_mode(True);
                ctxt.emit(event);
                context.setState(MainMap::Space);
            }
            catch (...)
            {
                context.setState(MainMap::Space);
                throw;
            }
            (context.getState()).Entry(context);
        }

        return;
    }

    void MainMap_PreSpace::keyup(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_space )
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.emit_space();
                context.popState();
            }
            catch (...)
            {
                context.popState();
                throw;
            }
        }
        else if ( event.is_slash )
    
    {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.emit_slash();
                context.setState(MainMap::PostSpace);
            }
            catch (...)
            {
                context.setState(MainMap::PostSpace);
                throw;
            }
            (context.getState()).Entry(context);
        }
        else if ( event.is_z )
    
    {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.emit_z();
                context.setState(MainMap::PostSpace);
            }
            catch (...)
            {
                context.setState(MainMap::PostSpace);
                throw;
            }
            (context.getState()).Entry(context);
        }        else
        {
             MainMap_Default::keyup(context, event);
        }

        return;
    }

    void MainMap_Space::Entry(satsukiContext& context)

{
        Turnstile& ctxt = context.getOwner();

        ctxt.space_mode(True);
        return;
    }

    void MainMap_Space::Exit(satsukiContext& context)

{
        Turnstile& ctxt = context.getOwner();

        ctxt.space_mode(False);
        return;
    }

    void MainMap_Space::keydown(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_slash )
        {
            // No actions.
            context.pushState(MainMap::PreSlashControl);
            (context.getState()).Entry(context);
        }
        else if ( event.is_z )
    
    {
            // No actions.
            context.pushState(MainMap::PreZKeyControl);
            (context.getState()).Entry(context);
        }
        else if ( event.is_space )
    
    {
            // No actions.
        }
        else
        {
            TurnstileState& endState = context.getState();

            context.clearState();
            try
            {
                ctxt.emit(event);
                context.setState(endState);
            }
            catch (...)
            {
                context.setState(endState);
                throw;
            }
        }

        return;
    }

    void MainMap_Space::keyup(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_space )
        {
            (context.getState()).Exit(context);
            // No actions.
            context.popState();
        }
        else if ( event.is_slash )
    
    {
            (context.getState()).Exit(context);
            // No actions.
            context.setState(MainMap::NestedSpace);
            (context.getState()).Entry(context);
        }
        else if ( event.is_z )
    
    {
            (context.getState()).Exit(context);
            // No actions.
            context.setState(MainMap::NestedSpace);
            (context.getState()).Entry(context);
        }
        else
        {
            TurnstileState& endState = context.getState();

            context.clearState();
            try
            {
                ctxt.emit(event);
                context.setState(endState);
            }
            catch (...)
            {
                context.setState(endState);
                throw;
            }
        }

        return;
    }

    void MainMap_PreZKeyControl::keydown(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_z )
        {
            (context.getState()).Exit(context);
            // No actions.
            context.setState(MainMap::ZKeyControl);
            (context.getState()).Entry(context);
        }
        else if ( event.is_space )
    
    {
            (context.getState()).Exit(context);
            // No actions.
            context.setState(MainMap::ZKeyControl);

            (context.getState()).Entry(context);
            context.pushState(MainMap::PreSpace);
            (context.getState()).Entry(context);
        }
        else
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.buffer(event);
                context.setState(MainMap::SemiZKeyControl);
            }
            catch (...)
            {
                context.setState(MainMap::SemiZKeyControl);
                throw;
            }
            (context.getState()).Entry(context);
        }

        return;
    }

    void MainMap_PreZKeyControl::keyup(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_z )
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.emit_z();
                context.popState();
            }
            catch (...)
            {
                context.popState();
                throw;
            }
        }
        else if ( event.is_space )
    
    {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.emit_slash();
                context.setState(MainMap::NestedZKeyControl);
            }
            catch (...)
            {
                context.setState(MainMap::NestedZKeyControl);
                throw;
            }
            (context.getState()).Entry(context);
        }        else
        {
             MainMap_Default::keyup(context, event);
        }

        return;
    }

    void MainMap_PreSlashControl::keydown(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_slash )
        {
            (context.getState()).Exit(context);
            // No actions.
            context.setState(MainMap::SlashControl);
            (context.getState()).Entry(context);
        }
        else if ( event.is_space )
    
    {
            (context.getState()).Exit(context);
            // No actions.
            context.setState(MainMap::SlashControl);

            (context.getState()).Entry(context);
            context.pushState(MainMap::PreSpace);
            (context.getState()).Entry(context);
        }
        else
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.buffer(event);
                context.setState(MainMap::SemiSlashControl);
            }
            catch (...)
            {
                context.setState(MainMap::SemiSlashControl);
                throw;
            }
            (context.getState()).Entry(context);
        }

        return;
    }

    void MainMap_PreSlashControl::keyup(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_slash )
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.emit_slash();
                context.popState();
            }
            catch (...)
            {
                context.popState();
                throw;
            }
        }
        else if ( event.is_space )
    
    {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.emit_slash();
                context.setState(MainMap::NestedSlashControl);
            }
            catch (...)
            {
                context.setState(MainMap::NestedSlashControl);
                throw;
            }
            (context.getState()).Entry(context);
        }        else
        {
             MainMap_Default::keyup(context, event);
        }

        return;
    }

    void MainMap_SemiZKeyControl::keydown(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.control_mode(True);
            ctxt.flush();
            ctxt.emit(event);
            context.setState(MainMap::ZKeyControl);
        }
        catch (...)
        {
            context.setState(MainMap::ZKeyControl);
            throw;
        }
        (context.getState()).Entry(context);

        return;
    }

    void MainMap_SemiZKeyControl::keyup(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_z )
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.emit_z();
                ctxt.flush();
                ctxt.emit(event);
                context.popState();
            }
            catch (...)
            {
                context.popState();
                throw;
            }
        }
        else if ( event.is_space )
    
    {
            (context.getState()).Exit(context);
            // No actions.
            context.setState(MainMap::NestedZKeyControl);
            (context.getState()).Entry(context);
        }
        else
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.control_mode(True);
                ctxt.flush();
                ctxt.emit(event);
                context.setState(MainMap::ZKeyControl);
            }
            catch (...)
            {
                context.setState(MainMap::ZKeyControl);
                throw;
            }
            (context.getState()).Entry(context);
        }

        return;
    }

    void MainMap_SemiSlashControl::keydown(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        (context.getState()).Exit(context);
        context.clearState();
        try
        {
            ctxt.control_mode(True);
            ctxt.flush();
            ctxt.emit(event);
            context.setState(MainMap::SlashControl);
        }
        catch (...)
        {
            context.setState(MainMap::SlashControl);
            throw;
        }
        (context.getState()).Entry(context);

        return;
    }

    void MainMap_SemiSlashControl::keyup(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_slash )
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.emit_slash();
                ctxt.flush();
                ctxt.emit(event);
                context.popState();
            }
            catch (...)
            {
                context.popState();
                throw;
            }
        }
        else if ( event.is_space )
    
    {
            (context.getState()).Exit(context);
            // No actions.
            context.setState(MainMap::NestedSlashControl);
            (context.getState()).Entry(context);
        }
        else
        {
            (context.getState()).Exit(context);
            context.clearState();
            try
            {
                ctxt.control_mode(True);
                ctxt.flush();
                ctxt.emit(event);
                context.setState(MainMap::SlashControl);
            }
            catch (...)
            {
                context.setState(MainMap::SlashControl);
                throw;
            }
            (context.getState()).Entry(context);
        }

        return;
    }

    void MainMap_ZKeyControl::Entry(satsukiContext& context)

{
        Turnstile& ctxt = context.getOwner();

        ctxt.control_mode(True);
        return;
    }

    void MainMap_ZKeyControl::Exit(satsukiContext& context)

{
        Turnstile& ctxt = context.getOwner();

        ctxt.control_mode(False);
        return;
    }

    void MainMap_ZKeyControl::keydown(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_z )
        {
            // No actions.
        }
        else if ( event.is_space )
    
    {
            // No actions.
            context.pushState(MainMap::PreSpace);
            (context.getState()).Entry(context);
        }
        else
        {
            TurnstileState& endState = context.getState();

            context.clearState();
            try
            {
                ctxt.emit(event);
                context.setState(endState);
            }
            catch (...)
            {
                context.setState(endState);
                throw;
            }
        }

        return;
    }

    void MainMap_ZKeyControl::keyup(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_z )
        {
            (context.getState()).Exit(context);
            // No actions.
            context.popState();
        }
        else if ( event.is_space )
    
    {
            (context.getState()).Exit(context);
            // No actions.
            context.setState(MainMap::NestedZKeyControl);
            (context.getState()).Entry(context);
        }
        else
        {
            TurnstileState& endState = context.getState();

            context.clearState();
            try
            {
                ctxt.emit(event);
                context.setState(endState);
            }
            catch (...)
            {
                context.setState(endState);
                throw;
            }
        }

        return;
    }

    void MainMap_SlashControl::Entry(satsukiContext& context)

{
        Turnstile& ctxt = context.getOwner();

        ctxt.control_mode(True);
        return;
    }

    void MainMap_SlashControl::Exit(satsukiContext& context)

{
        Turnstile& ctxt = context.getOwner();

        ctxt.control_mode(False);
        return;
    }

    void MainMap_SlashControl::keydown(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_slash )
        {
            // No actions.
        }
        else
        {
            TurnstileState& endState = context.getState();

            context.clearState();
            try
            {
                ctxt.emit(event);
                context.setState(endState);
            }
            catch (...)
            {
                context.setState(endState);
                throw;
            }
        }

        return;
    }

    void MainMap_SlashControl::keyup(satsukiContext& context, KeyEvent event)
    {
        Turnstile& ctxt = context.getOwner();

        if ( event.is_slash )
        {
            (context.getState()).Exit(context);
            // No actions.
            context.popState();
        }
        else if ( event.is_space )
    
    {
            (context.getState()).Exit(context);
            // No actions.
            context.setState(MainMap::NestedSlashControl);
            (context.getState()).Entry(context);
        }
        else
        {
            TurnstileState& endState = context.getState();

            context.clearState();
            try
            {
                ctxt.emit(event);
                context.setState(endState);
            }
            catch (...)
            {
                context.setState(endState);
                throw;
            }
        }

        return;
    }
}

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
