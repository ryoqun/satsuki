# ex: set ro:
# DO NOT EDIT.
# generated by smc (http://smc.sourceforge.net/)
# from file : satsuki.sm

module Turnstile

    require 'statemap'

    class TurnstileState < Statemap::State

        def Entry(fsm) end

        def Exit(fsm) end

        def method_missing(name, *args)
            fsm = args.shift
            Default(fsm)
        end

        def Default(fsm)
            msg = "\nState: " + fsm.getState.getName +
                "\nTransition: " + fsm.getTransition.to_s + "\n"
            raise Statemap::TransitionUndefinedException, msg
        end

    end

    class MainMap_Default < TurnstileState

    end

    class MainMap_Normal < MainMap_Default

        def keydown(fsm, event)
            ctxt = fsm.getOwner
            if  event.name == :space  then
                # No actions.
                fsm.pushState(Turnstile::SpaceMap::PreSpace)
                fsm.getState.Entry(fsm)
            elsif  event.name == :slash  then
                # No actions.
                fsm.pushState(Turnstile::ControlMap::PreSlashControl)
                fsm.getState.Entry(fsm)
            elsif  event.name == :z  then
                # No actions.
                fsm.pushState(Turnstile::ControlMap::PreZKeyControl)
                fsm.getState.Entry(fsm)
            else
                endState = fsm.getState
                fsm.clearState
                begin
                    ctxt.convert_and_emit(event)
                ensure
                    fsm.setState(endState)
                end
            end
        end

    end

    module MainMap

        Normal = MainMap_Normal::new('MainMap.Normal', 0).freeze
        Default = MainMap_Default::new('MainMap.Default', -1).freeze

    end

    class SpaceMap_Default < TurnstileState

    end

    class SpaceMap_PreSpace < SpaceMap_Default

        def keyup(fsm, event)
            ctxt = fsm.getOwner
                if  event.name == :space  then
                    fsm.getState.Exit(fsm)
                    fsm.clearState
                    begin
                        ctxt.emit_space_key_event()
                    ensure
                        fsm.popState
                    end
            else
                super
            end
        end

        def keydown(fsm, event)
            ctxt = fsm.getOwner
            if  event.name == :slash  then
                fsm.getState.Exit(fsm)
                # No actions.
                fsm.setState(SpaceMap::Space)
                fsm.getState.Entry(fsm)
                fsm.pushState(Turnstile::ControlMap::PreSlashControl)
                fsm.getState.Entry(fsm)
            elsif  event.name == :z  then
                fsm.getState.Exit(fsm)
                # No actions.
                fsm.setState(SpaceMap::Space)
                fsm.getState.Entry(fsm)
                fsm.pushState(Turnstile::ControlMap::PreZKeyControl)
                fsm.getState.Entry(fsm)
            else
                fsm.getState.Exit(fsm)
                fsm.clearState
                begin
                    ctxt.convert_and_emit(event)
                ensure
                    fsm.setState(SpaceMap::Space)
                    fsm.getState.Entry(fsm)
                end
            end
        end

    end

    class SpaceMap_Space < SpaceMap_Default

        def Entry(fsm)
            ctxt = fsm.getOwner
            ctxt.space_mode(true)
        end

        def Exit(fsm)
            ctxt = fsm.getOwner
            ctxt.space_mode(false)
        end

        def keydown(fsm, event)
            ctxt = fsm.getOwner
            if  event.name == :slash  then
                # No actions.
                fsm.pushState(Turnstile::ControlMap::PreSlashControl)
                fsm.getState.Entry(fsm)
            elsif  event.name == :z  then
                # No actions.
                fsm.pushState(Turnstile::ControlMap::PreZKeyControl)
                fsm.getState.Entry(fsm)
            else
                endState = fsm.getState
                fsm.clearState
                begin
                    ctxt.convert_and_emit(event)
                ensure
                    fsm.setState(endState)
                end
            end
        end

        def keyup(fsm, event)
            if  event.name == :space  then
                fsm.getState.Exit(fsm)
                # No actions.
                fsm.popState
            else
            end
        end

    end

    module SpaceMap

        PreSpace = SpaceMap_PreSpace::new('SpaceMap.PreSpace', 1).freeze
        Space = SpaceMap_Space::new('SpaceMap.Space', 2).freeze
        Default = SpaceMap_Default::new('SpaceMap.Default', -1).freeze

    end

    class ShiftMap_Default < TurnstileState

    end

    module ShiftMap

        Default = ShiftMap_Default::new('ShiftMap.Default', -1).freeze

    end

    class NumMap_Default < TurnstileState

    end

    module NumMap

        Default = NumMap_Default::new('NumMap.Default', -1).freeze

    end

    class ControlMap_Default < TurnstileState

    end

    class ControlMap_PreSlashControl < ControlMap_Default

        def keyup(fsm, event)
            ctxt = fsm.getOwner
                if  event.name == :slash  then
                    fsm.getState.Exit(fsm)
                    fsm.clearState
                    begin
                        ctxt.convert_and_emit(event)
                    ensure
                        fsm.popState
                    end
            else
                super
            end
        end

        def keydown(fsm, event)
            ctxt = fsm.getOwner
            fsm.getState.Exit(fsm)
            fsm.clearState
            begin
                ctxt.emit_control(event)
            ensure
                fsm.setState(ControlMap::SlashControl)
                fsm.getState.Entry(fsm)
            end
        end

    end

    class ControlMap_PreZKeyControl < ControlMap_Default

        def keyup(fsm, event)
            ctxt = fsm.getOwner
                if  event.name == :z  then
                    fsm.getState.Exit(fsm)
                    fsm.clearState
                    begin
                        ctxt.convert_and_emit(event)
                    ensure
                        fsm.popState
                    end
            else
                super
            end
        end

        def keydown(fsm, event)
            ctxt = fsm.getOwner
            fsm.getState.Exit(fsm)
            fsm.clearState
            begin
                ctxt.emit_control(event)
            ensure
                fsm.setState(ControlMap::ZKeyControl)
                fsm.getState.Entry(fsm)
            end
        end

    end

    class ControlMap_ZKeyControl < ControlMap_Default

        def keyup(fsm, event)
                if  event.name == :z  then
                    fsm.getState.Exit(fsm)
                    # No actions.
                    fsm.popState
            else
                super
            end
        end

    end

    class ControlMap_SlashControl < ControlMap_Default

        def keyup(fsm, event)
                if  event.name == :slash  then
                    fsm.getState.Exit(fsm)
                    # No actions.
                    fsm.popState
            else
                super
            end
        end

    end

    module ControlMap

        PreSlashControl = ControlMap_PreSlashControl::new('ControlMap.PreSlashControl', 3).freeze
        PreZKeyControl = ControlMap_PreZKeyControl::new('ControlMap.PreZKeyControl', 4).freeze
        ZKeyControl = ControlMap_ZKeyControl::new('ControlMap.ZKeyControl', 5).freeze
        SlashControl = ControlMap_SlashControl::new('ControlMap.SlashControl', 6).freeze
        Default = ControlMap_Default::new('ControlMap.Default', -1).freeze

    end

    class Turnstile_sm < Statemap::FSMContext

        def initialize(owner)
            super(MainMap::Normal)
            @_owner = owner
        end

        def enterStartState()
            getState.Entry(self)
        end

        def method_missing(name, *args)
            @_transition = name
            getState.send(name, self, *args)
            @_transition = nil
        end

        def getOwner()
            return @_owner
        end

    end

end

# Local variables:
#  buffer-read-only: t
# End:
